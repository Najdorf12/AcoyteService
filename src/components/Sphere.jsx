/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 scene.gltf --transform 
Files: scene.gltf [4.27KB] > C:\Users\Admin\Projects\GRUPO LA COMUINIDAD\acoyteservice\acoyteservice-app\public\scene-transformed.glb [327.85KB] (-7578%)
Author: cherkesgiller (https://sketchfab.com/cherkesgiller)
License: CC-BY-NC-ND-4.0 (http://creativecommons.org/licenses/by-nc-nd/4.0/)
Source: https://sketchfab.com/3d-models/abstract-design-5f61a7b5eaa64af093d7cd721c9ef5ad
Title: Abstract Design
*/

import React, { useRef, useLayoutEffect } from "react";
import { useGLTF } from "@react-three/drei";
import gsap from "gsap";
import { ScrollTrigger } from "gsap/ScrollTrigger";
import { GUI } from "dat.gui";
import { Float } from "@react-three/drei";

gsap.registerPlugin(ScrollTrigger);

export const Sphere = (props) => {
  const { nodes, materials } = useGLTF("/scene-transformed.glb");
  const sphere = useRef();
  const tl = gsap.timeline();
  /* DEBUG MODEL3D */
 /*  useLayoutEffect(() => {
    const gui = new GUI({ width: 400 });

    const debugRotation = {
      rotation: {
        x: 0,
        y: 0,
        z: 0,
      },
    };
    const debugPosition = {
      position: {
        x: 0,
        y: 0,
        z: 0,
      },
    };

    //Rotation
    gui
      .add(debugRotation.rotation, "x")
      .min(-30)
      .max(30)
      .step(0.005)
      .onChange(() => {
        sphere.current.rotation.x = debugRotation.rotation.x;
      })
      .name("Rotation X");
    gui
      .add(debugRotation.rotation, "y")
      .min(-30)
      .max(30)
      .step(0.005)
      .onChange(() => {
        sphere.current.rotation.y = debugRotation.rotation.y;
      })
      .name("Rotation Y");
    gui
      .add(debugRotation.rotation, "z")
      .min(-30)
      .max(30)
      .step(0.005)
      .onChange(() => {
        sphere.current.rotation.z = debugRotation.rotation.z;
      })
      .name("Rotation Z");
    // Position
    gui
      .add(debugPosition.position, "x")
      .min(-30)
      .max(30)
      .step(0.005)
      .onChange(() => {
        sphere.current.position.x = debugPosition.position.x;
      })
      .name("Posit X");
    gui
      .add(debugPosition.position, "y")
      .min(-30)
      .max(30)
      .step(0.05)
      .onChange(() => {
        sphere.current.position.y = debugPosition.position.y;
      })
      .name("Posit Y");
    gui
      .add(debugPosition.position, "z")
      .min(-600)
      .max(200)
      .step(0.05)
      .onChange(() => {
        sphere.current.position.z = debugPosition.position.z;
      })
      .name("Posit Z");

    return () => {
      gui.destroy();
    };
  }, []); */
  /* ANIMATIONS */
  useLayoutEffect(() => {
    const screen = window.screen.width;
    new ScrollTrigger({});
    tl.to(sphere.current?.position, {
      x: screen > 1000 ? 0 : 30,
      y: screen > 1000 ? 0 : -30,
      z: screen > 1000 ? 0 : 130,
      ease: "power1.out",
      scrollTrigger: {
        trigger: "#second_section",
        start: "top bottom",
        end: "top top",
        scrub: true,
        immediateRender: false,
      },
    })
      .to(sphere.current?.rotation, {
        x:screen > 1000 ? 0 : -.24, 
        y: screen > 1000 ? 0 : -.8,
        ease: "power1.out",
        scrollTrigger: {
          trigger: "#second_section",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false,
        },
      })
      tl.to(sphere.current?.position, {
        x: screen > 1000 ? 0 : 80,
        y: screen > 1000 ? 0 : 0,
        z: screen > 1000 ? 0 : 220,
        ease: "power1.out",
        scrollTrigger: {
          trigger: "#third-section",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false,
        },
      })
      .to(sphere.current?.rotation, {
        x: screen > 1000 ? 0 : -.2, 
        y: screen > 1000 ? 0 : -2,
       
        ease: "power1.out",
        scrollTrigger: {
          trigger: "#third-section",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false,
        },
      }) 
        
        tl.to(sphere.current?.position, {
          x:screen > 1000 ? 0 : 100,
          y:screen > 1000 ? 0 : -20,
          z: screen > 1000 ? 0 : 200,
          ease: "power1.out",
          scrollTrigger: {
            trigger: "#brand-section",
            start: "top bottom",
            end: "top top",
            scrub: true,
            immediateRender: false,
          },
        })
          .to(sphere.current?.rotation, { 
            y: screen > 1000 ? 0 : -.1,
            ease: "power1.out",
            scrollTrigger: {
              trigger: "#brand-section",
              start: "top bottom",
              end: "top top",
              scrub: true,
              immediateRender: false,
            },
          }) .to(sphere.current?.position, {
            x: screen > 1000 ? 0 : 30,
            y: screen > 1000 ? 0 : -30,
            z: screen > 1000 ? 0 : 130,
            ease: "power1.out",
            scrollTrigger: {
              trigger: "#contact-section",
              start: "top bottom",
              end: "top top",
              scrub: true,
              immediateRender: false,
            },
          })
            .to(sphere.current?.rotation, {
              x:screen > 1000 ? 0 : -.24, 
              y: screen > 1000 ? 0 : -.8,
              ease: "power1.out",
              scrollTrigger: {
                trigger: "#contact-section",
                start: "top bottom",
                end: "top top",
                scrub: true,
                immediateRender: false,
              },
            })
  }, []);

  return (
    <group ref={sphere} {...props} dispose={null} castShadow={true} >
      <Float
        speed={1} // Animation speed, defaults to 1
        /* rotationIntensity={3}  */// XYZ rotation intensity, defaults to 1
        floatIntensity={1.3} // Up/down float intensity, works like a multiplier with floatingRange,defaults to 1
        floatingRange={[1, 10]}
      >
        <mesh
          geometry={nodes.VoronoiDynoBake_Material_0.geometry}
          material={materials.Material}
          scale={100}
        />
      </Float>
    </group>
  );
};

useGLTF.preload("/scene-transformed.glb");
